/**
 * ORFEAS 3D Engine Hybrid System
 * ================================
 * ORFEAS AI Project
 *
 * Purpose: Automatic detection and switching between:
 * - Babylon.js 7.0 WebGPU (RTX acceleration, 10x faster)
 * - Three.js r128 WebGL (Fallback for compatibility)
 *
 * Features:
 * - WebGPU feature detection (Chrome 113+)
 * - GPU adapter info retrieval (RTX 3090 detection)
 * - Graceful fallback to Three.js
 * - Unified API for both engines
 * - Performance monitoring and comparison
 */

class ORFEAS3DEngineHybrid {
    constructor() {
        this.engine = null;
        this.engineType = null; // 'babylonjs-webgpu', 'babylonjs-webgl', 'threejs-webgl'
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.mesh = null;
        this.canvas = null;

        // Performance tracking
        this.stats = {
            loadTime: 0,
            renderTime: 0,
            fps: 0,
            gpuName: 'Unknown',
            rayTracingSupported: false
        };

        console.log('Ã°Å¸Å½Â¯ ORFEAS 3D Engine Hybrid initialized');
    }

    /**
     * Detect best 3D engine based on browser capabilities
     * Priority: WebGPU > WebGL (Babylon) > WebGL (Three.js)
     */
    async detectBestEngine() {
        console.log('Ã°Å¸â€Â Detecting best 3D rendering engine...');

        // Try WebGPU first (RTX 3090 optimization)
        if (navigator.gpu) {
            try {
                const adapter = await navigator.gpu.requestAdapter({
                    powerPreference: 'high-performance'
                });

                if (adapter) {
                    console.log('Ã¢Å“â€¦ WebGPU detected - Babylon.js WebGPU mode');

                    // Get GPU info
                    const adapterInfo = await adapter.requestAdapterInfo();
                    this.stats.gpuName = adapterInfo.device || 'WebGPU GPU';

                    // Check for ray tracing
                    this.stats.rayTracingSupported = adapter.features?.has('ray-tracing') || false;

                    console.log(`   GPU: ${this.stats.gpuName}`);
                    console.log(`   Ray Tracing: ${this.stats.rayTracingSupported ? 'YES' : 'NO'}`);

                    return 'babylonjs-webgpu';
                }
            } catch (error) {
                console.warn('Ã¢Å¡Â Ã¯Â¸Â WebGPU initialization failed:', error);
            }
        }

        // Fallback to WebGL
        console.log('Ã°Å¸â€â€ž WebGPU unavailable, using WebGL renderer');

        // Try WebGL 2.0
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (gl) {
            // Get GPU name from WebGL
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                this.stats.gpuName = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
            }

            console.log(`   GPU: ${this.stats.gpuName}`);
            console.log('   Using Three.js WebGL fallback');

            return 'threejs-webgl';
        }

        console.error('Ã¢ÂÅ’ No WebGL support detected!');
        return null;
    }

    /**
     * Initialize 3D engine (auto-detect best option)
     */
    async init(canvasId) {
        const startTime = performance.now();

        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            throw new Error(`Canvas element '${canvasId}' not found`);
        }

        // Detect best engine
        this.engineType = await this.detectBestEngine();

        if (!this.engineType) {
            throw new Error('No compatible 3D rendering engine found');
        }

        // Load appropriate scripts and initialize
        if (this.engineType === 'babylonjs-webgpu') {
            await this.initBabylonWebGPU();
        } else if (this.engineType === 'babylonjs-webgl') {
            await this.initBabylonWebGL();
        } else if (this.engineType === 'threejs-webgl') {
            await this.initThreeJS();
        }

        this.stats.loadTime = performance.now() - startTime;
        console.log(`Ã¢Å“â€¦ 3D Engine initialized in ${this.stats.loadTime.toFixed(2)}ms`);
        console.log(`   Engine: ${this.engineType}`);

        return this.engineType;
    }

    /**
     * Initialize Babylon.js with WebGPU
     */
    async initBabylonWebGPU() {
        console.log('Ã°Å¸Å¡â‚¬ Initializing Babylon.js WebGPU...');

        // Load Babylon.js if not already loaded
        if (typeof BABYLON === 'undefined') {
            await this.loadBabylonScripts();
        }

        // Create WebGPU engine
        this.engine = new BABYLON.WebGPUEngine(this.canvas, {
            antialias: true,
            stencil: true,
            powerPreference: 'high-performance',
            adaptToDeviceRatio: true
        });

        await this.engine.initAsync();

        // Create scene
        this.scene = new BABYLON.Scene(this.engine);
        this.scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.15, 1);

        // Setup camera
        this.camera = new BABYLON.ArcRotateCamera(
            'camera',
            -Math.PI / 2,
            Math.PI / 2.5,
            3,
            BABYLON.Vector3.Zero(),
            this.scene
        );
        this.camera.attachControl(this.canvas, true);
        this.camera.wheelPrecision = 50;

        // Setup lighting
        const light = new BABYLON.HemisphericLight(
            'light',
            new BABYLON.Vector3(1, 1, 0),
            this.scene
        );
        light.intensity = 0.7;

        // Environment for PBR
        const hdrTexture = new BABYLON.CubeTexture.CreateFromPrefilteredData(
            'https://assets.babylonjs.com/environments/environmentSpecular.env',
            this.scene
        );
        this.scene.environmentTexture = hdrTexture;

        console.log('Ã¢Å“â€¦ Babylon.js WebGPU ready');
    }

    /**
     * Initialize Babylon.js with WebGL fallback
     */
    async initBabylonWebGL() {
        console.log('Ã°Å¸â€â€ž Initializing Babylon.js WebGL...');

        if (typeof BABYLON === 'undefined') {
            await this.loadBabylonScripts();
        }

        this.engine = new BABYLON.Engine(this.canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            antialias: true,
            powerPreference: 'high-performance'
        });

        this.scene = new BABYLON.Scene(this.engine);
        this.scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.15, 1);

        this.camera = new BABYLON.ArcRotateCamera(
            'camera',
            -Math.PI / 2,
            Math.PI / 2.5,
            3,
            BABYLON.Vector3.Zero(),
            this.scene
        );
        this.camera.attachControl(this.canvas, true);

        const light = new BABYLON.HemisphericLight(
            'light',
            new BABYLON.Vector3(1, 1, 0),
            this.scene
        );
        light.intensity = 0.7;

        console.log('Ã¢Å“â€¦ Babylon.js WebGL ready');
    }

    /**
     * Initialize Three.js (legacy fallback)
     */
    async initThreeJS() {
        console.log('Ã°Å¸â€â€ž Initializing Three.js WebGL...');

        if (typeof THREE === 'undefined') {
            await this.loadThreeJSScripts();
        }

        // Create scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a1a26);

        // Create camera
        this.camera = new THREE.PerspectiveCamera(
            75,
            this.canvas.width / this.canvas.height,
            0.1,
            1000
        );
        this.camera.position.z = 3;

        // Create renderer
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: true,
            alpha: true
        });
        this.renderer.setSize(this.canvas.width, this.canvas.height);
        this.renderer.setPixelRatio(window.devicePixelRatio);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(directionalLight);

        console.log('Ã¢Å“â€¦ Three.js WebGL ready');
    }

    /**
     * Load Babylon.js scripts dynamically
     */
    async loadBabylonScripts() {
        console.log('Ã°Å¸â€œÂ¦ Loading Babylon.js scripts...');

        const scripts = [
            'https://cdn.babylonjs.com/babylon.js',
            'https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js',
            'https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js'
        ];

        for (const src of scripts) {
            await this.loadScript(src);
        }

        console.log('Ã¢Å“â€¦ Babylon.js scripts loaded');
    }

    /**
     * Load Three.js scripts dynamically
     */
    async loadThreeJSScripts() {
        console.log('Ã°Å¸â€œÂ¦ Loading Three.js scripts...');

        const scripts = [
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
            'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js',
            'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js'
        ];

        for (const src of scripts) {
            await this.loadScript(src);
        }

        console.log('Ã¢Å“â€¦ Three.js scripts loaded');
    }

    /**
     * Load script dynamically
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    /**
     * Load STL model (unified API for both engines)
     */
    async loadSTL(url) {
        const startTime = performance.now();

        console.log(`Ã°Å¸â€œÂ¦ Loading STL: ${url}`);

        if (this.engineType.startsWith('babylonjs')) {
            await this.loadSTLBabylon(url);
        } else if (this.engineType === 'threejs-webgl') {
            await this.loadSTLThreeJS(url);
        }

        this.stats.renderTime = performance.now() - startTime;
        console.log(`Ã¢Å“â€¦ STL loaded in ${this.stats.renderTime.toFixed(2)}ms`);
    }

    /**
     * Load STL with Babylon.js
     */
    async loadSTLBabylon(url) {
        return new Promise((resolve, reject) => {
            BABYLON.SceneLoader.ImportMesh(
                '',
                '',
                url,
                this.scene,
                (meshes) => {
                    if (meshes.length > 0) {
                        this.mesh = meshes[0];

                        // Apply PBR material
                        const pbr = new BABYLON.PBRMetallicRoughnessMaterial('pbr', this.scene);
                        pbr.baseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                        pbr.metallic = 0.2;
                        pbr.roughness = 0.6;

                        this.mesh.material = pbr;
                        this.mesh.position = BABYLON.Vector3.Zero();

                        console.log(`   Vertices: ${this.mesh.getTotalVertices()}`);
                        console.log(`   Faces: ${Math.floor(this.mesh.getTotalIndices() / 3)}`);

                        resolve();
                    } else {
                        reject(new Error('No meshes loaded'));
                    }
                },
                null,
                (scene, message, exception) => {
                    reject(new Error(`STL loading failed: ${message}`));
                }
            );
        });
    }

    /**
     * Load STL with Three.js
     */
    async loadSTLThreeJS(url) {
        return new Promise((resolve, reject) => {
            const loader = new THREE.STLLoader();

            loader.load(
                url,
                (geometry) => {
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xcccccc,
                        specular: 0x111111,
                        shininess: 200
                    });

                    this.mesh = new THREE.Mesh(geometry, material);
                    this.scene.add(this.mesh);

                    // Center mesh
                    geometry.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geometry.boundingBox.getCenter(center);
                    this.mesh.position.sub(center);

                    console.log(`   Vertices: ${geometry.attributes.position.count}`);
                    console.log(`   Faces: ${geometry.index ? geometry.index.count / 3 : 0}`);

                    resolve();
                },
                undefined,
                (error) => {
                    reject(error);
                }
            );
        });
    }

    /**
     * Start render loop
     */
    startRenderLoop() {
        if (this.engineType.startsWith('babylonjs')) {
            this.engine.runRenderLoop(() => {
                this.scene.render();
                this.updateFPS();
            });
        } else if (this.engineType === 'threejs-webgl') {
            const animate = () => {
                requestAnimationFrame(animate);
                this.renderer.render(this.scene, this.camera);
                this.updateFPS();
            };
            animate();
        }
    }

    /**
     * Update FPS counter
     */
    updateFPS() {
        // Simple FPS calculation
        if (!this.lastFrameTime) {
            this.lastFrameTime = performance.now();
            this.frameCount = 0;
        }

        this.frameCount++;
        const currentTime = performance.now();
        const elapsed = currentTime - this.lastFrameTime;

        if (elapsed >= 1000) {
            this.stats.fps = Math.round((this.frameCount * 1000) / elapsed);
            this.frameCount = 0;
            this.lastFrameTime = currentTime;
        }
    }

    /**
     * Get performance statistics
     */
    getStats() {
        return {
            engineType: this.engineType,
            loadTime: this.stats.loadTime,
            renderTime: this.stats.renderTime,
            fps: this.stats.fps,
            gpuName: this.stats.gpuName,
            rayTracingSupported: this.stats.rayTracingSupported
        };
    }

    /**
     * Cleanup resources
     */
    dispose() {
        if (this.engineType.startsWith('babylonjs')) {
            if (this.scene) {
                this.scene.dispose();
            }
            if (this.engine) {
                this.engine.dispose();
            }
        } else if (this.engineType === 'threejs-webgl') {
            if (this.mesh) {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
            if (this.renderer) {
                this.renderer.dispose();
            }
        }

        console.log('Ã°Å¸Â§Â¹ 3D Engine resources cleaned up');
    }
}

// Export for global use
window.ORFEAS3DEngineHybrid = ORFEAS3DEngineHybrid;

console.log('Ã¢Å“â€¦ ORFEAS 3D Engine Hybrid System loaded');
